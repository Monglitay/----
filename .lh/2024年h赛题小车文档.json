{
    "sourceFile": "2024年h赛题小车文档",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748757327052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748757327052,
            "name": "Commit-0",
            "content": "#include \"ti_msp_dl_config.h\"\r\n#include \"encoder.h\"\r\n#include \"hc_06.h\"\r\n#include \"delay.h\"\r\n#include \"tb6612.h\"\r\n#include \"motor.h\"\r\n#include \"task.h\"\r\n#include \"jy62.h\"\r\n#include \"tracking.h\"\r\n#include \"buzzer.h\" \r\n\r\n\r\n// 小车运行速度\r\nstatic float speed = 12;\r\n\r\n// 状态机状态变量\r\nint state = 0;\r\n// 计数器\r\nint cnt = 0;\r\n\r\n// 上一次转向时间\r\nint32_t last_turned_ticks = 0;\r\n// 转向标志位\r\nint turning_flag = 0;\r\n//最大转向时间\r\n#define MAX_TURNING_TICKS 3000\r\n\r\n// 任务声明\r\nvoid Task_1();\r\nvoid Task_2();\r\nvoid Task_3();\r\n\r\n/**\r\n * @brief 主函数入口\r\n * @details \r\n * 1. 初始化系统配置\r\n * 2. 初始化各模块：蓝牙、电机、循迹、编码器、蜂鸣器\r\n * 3. 进入主循环，执行循迹任务\r\n */\r\nint main(void)\r\n{\r\n    // 系统级配置初始化\r\n    SYSCFG_DL_init();\r\n    \r\n    // 外设模块初始化\r\n    HC06_Init();     // 蓝牙模块初始化\r\n    Motor_Init();    // 电机控制初始化\r\n    Tracking_Init(); // 循迹模块初始化\r\n    Encoder_Init();  // 编码器初始化\r\n    Buzzer_Init();   // 蜂鸣器初始化\r\n    JY62_Init();\r\n    JY62_SendCalibrationCmd(JY62_RESET_YAW);\r\n    delay_ms(1000);\r\n    // 进入主循环，执行任务\r\n    while (1) \r\n    {   \r\n        Task_2();\r\n    }\r\n}\r\n\r\n/**\r\n * @brief 巡线小车直线路径运动控制函数（AB)\r\n * @details 通过状态机实现小车在A点处直行到B点\r\n * 状态机工作流程：\r\n * - state 0: 从A运动到B,走0度直线\r\n * - state 1: 检测到达B点\r\n */\r\nvoid Task_1()\r\n{\r\n    // 周期性处理MPU6050、电机控制和蜂鸣器\r\n    Motor_Proc();\r\n    Buzzer_Proc();\r\n    JY62_UpdateAngles();\r\n    // 状态机状态0：初始状态\r\n    if(state == 0)\r\n    {\r\n        BUZZER_LONG_BEEP;         // 蜂鸣器提示\r\n        tracking_flag = 0;         // 关闭循迹\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        Motor_direction(0);        // 设置电机方向\r\n        \r\n        // 检测是否脱离黑线\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > 10)             \r\n            {\r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // 状态1：检测黑线\r\n    else if(state == 1)\r\n    {\r\n        Motor_direction(0);\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > 10)             // 检测到黑线持续\r\n            {\r\n                BUZZER_LONG_BEEP;\r\n                state = 2;            // 进入状态二\r\n                cnt = 0;\r\n                Motor_SetSpeed_R(0);   // 设置右电机速度\r\n                Motor_SetSpeed_L(0);   // 设置左电机速度\r\n                return;\r\n            }\r\n        }\r\n        else cnt = 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @brief 巡线小车椭圆路径运动控制函数（ABCDA)\r\n * @details 通过状态机实现小车在两个半圆上连续运动1圈\r\n * 状态机工作流程：\r\n * - state 0: 从A运动到B,走0度直线\r\n * - state 1: 检测到达B点，并回正\r\n * - state 2：从B巡线到C\r\n * - state 3: 从C运动到D，走225度直线\r\n * - state 4: 从D运动到A，在结尾处回正\r\n */\r\nvoid Task_2()\r\n{\r\n    // 周期性处理传感器和执行器\r\n    Motor_Proc();\r\n    Buzzer_Proc();\r\n    JY62_UpdateAngles();\r\n    \r\n    // 状态0：初始行驶状态\r\n    if(state == 0)\r\n    {\r\n        tracking_flag = 0;         // 关闭循迹\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        Motor_direction(0);        // 设置电机方向直行\r\n        \r\n        // 检测是否脱离黑线\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > 5000)             \r\n            {\r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        }\r\n        else cnt = 0;\r\n    }\r\n    // 状态1：检测到B点并回正\r\n    else if(state == 1)\r\n    {\r\n        // 类似Task_3中状态1的回正逻辑\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt >50)             \r\n            {\r\n                    \r\n                    BUZZER_LONG_BEEP;   // 进入状态2\r\n                    state = 2;  \r\n                    tracking_flag = 1;             \r\n                    cnt = 0;\r\n                    return;\r\n            }\r\n        }else cnt = 0;\r\n    }\r\n        \r\n    // 状态2：进入循迹模式（从B到C）\r\n    else if (state == 2)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > 5000)             \r\n            {   \r\n                BUZZER_LONG_BEEP;                \r\n                state = 3;           \r\n                tracking_flag = 0;\r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态3：从C运动到D\r\n    else if (state == 3)\r\n    {\r\n        \r\n        Motor_direction(178);\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > 50)             \r\n            {\r\n                BUZZER_LONG_BEEP;                \r\n                state = 4;           \r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态4：从D运动到A\r\n    else if (state == 4)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt >5000)             \r\n            {\r\n                BUZZER_LONG_BEEP;                \r\n                state = 0;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @brief 巡线小车8字路径运动控制函数(ACBDA)\r\n * @details 通过状态机实现小车在两个半圆上连续运动1圈\r\n * 状态机工作流程：\r\n * - state 0: 从A运动到C,走-45度直线\r\n * - state 1: 检测到达C点，并回正\r\n * - state 2：从C巡线到B，并在B点回正\r\n * - state 3: 从B运动到D，走225度直线\r\n * - state 4: 从D运动到A，在结尾处回正\r\n */\r\nvoid Task_3()\r\n{\r\n    // 周期性处理传感器和执行器\r\n    Motor_Proc();\r\n    Buzzer_Proc();\r\n    JY62_UpdateAngles();\r\n    \r\n    // 状态0：初始行驶状态\r\n    if(state == 0)\r\n    {\r\n        if(state == 0)\r\n        {\r\n        tracking_flag = 0;         // 关闭循迹\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        Motor_direction(0);        // 设置电机方向直行\r\n        }\r\n        // 检测是否脱离黑线\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > 30)             \r\n            {\r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        }\r\n        else cnt = 0;\r\n    }\r\n    // 状态1：检测到B点并回正\r\n    else if(state == 1)\r\n    {\r\n        if(turning_flag == 0)\r\n            last_turned_ticks = get_ticks();\r\n        turning_flag = 1;\r\n        if(get_ticks()-last_turned_ticks < 2000)\r\n        {\r\n            Motor_SetSpeed_R(0);   // 设置右电机速度\r\n            Motor_SetSpeed_L(0);   // 设置左电机速度\r\n            Motor_direction(-40);\r\n            \r\n            return;\r\n        }\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        // 类似Task_3中状态1的回正逻辑\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt >5)             \r\n            {\r\n                turning_flag = 0;\r\n                BUZZER_LONG_BEEP;   // 进入状态2\r\n                state = 2;  \r\n                tracking_flag = 1;             \r\n                cnt = 0;\r\n                return;\r\n            }\r\n        }else cnt = 0;\r\n    }\r\n        \r\n    // 状态2：进入循迹模式（从B到C）\r\n    else if (state == 2)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt >30)             \r\n            {   \r\n                BUZZER_LONG_BEEP;                \r\n                state = 3;           \r\n                tracking_flag = 0;\r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态3：从C运动到D\r\n    else if (state == 3)\r\n    {\r\n        \r\n        if(turning_flag == 0)\r\n            last_turned_ticks = get_ticks();\r\n        turning_flag = 1;\r\n        if(get_ticks()-last_turned_ticks < 2000)\r\n        {\r\n            Motor_SetSpeed_R(0);   // 设置右电机速度\r\n            Motor_SetSpeed_L(0);   // 设置左电机速度\r\n            Motor_direction(-140);\r\n            return;\r\n        }\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        \r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > 5)             \r\n            {\r\n                Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n                Motor_SetSpeed_L(speed);\r\n                turning_flag = 0;\r\n                BUZZER_LONG_BEEP;                \r\n                state = 4;           \r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态4：从D运动到A\r\n    else if (state == 4)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt >30)             \r\n            {\r\n                BUZZER_LONG_BEEP;                \r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                Motor_SetSpeed_L(0);\r\n                Motor_SetSpeed_R(0);\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n}\r\n"
        }
    ]
}