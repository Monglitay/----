{
    "sourceFile": "project_3_Car_Learning/Patrol Car/README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1748767291179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748767362814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n | MP1584EN     | 14.8V    | 5V        | 3A       | 红外传感器阵列   |\r\n \r\n ### 1.4 电路图\r\n \r\n-![未能找到电路图图片](project_3_Car_Learning\\小车电路图.png)\r\n+![未能找到电路图图片](小车电路图.png)\r\n \r\n ## 二、软件架构实现\r\n \r\n ### 2.1 开发环境\r\n"
                },
                {
                    "date": 1748767433172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n | MP1584EN     | 14.8V    | 5V        | 3A       | 红外传感器阵列   |\r\n \r\n ### 1.4 电路图\r\n \r\n-![未能找到电路图图片](小车电路图.png)\r\n+![未能找到电路图图片](/小车电路图.png)\r\n \r\n ## 二、软件架构实现\r\n \r\n ### 2.1 开发环境\r\n"
                },
                {
                    "date": 1748767440273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n | MP1584EN     | 14.8V    | 5V        | 3A       | 红外传感器阵列   |\r\n \r\n ### 1.4 电路图\r\n \r\n-![未能找到电路图图片](/小车电路图.png)\r\n+![未能找到电路图图片](/project_3_Car_Learning/小车电路图.png小车电路图.png)\r\n \r\n ## 二、软件架构实现\r\n \r\n ### 2.1 开发环境\r\n"
                },
                {
                    "date": 1748767445380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n | MP1584EN     | 14.8V    | 5V        | 3A       | 红外传感器阵列   |\r\n \r\n ### 1.4 电路图\r\n \r\n-![未能找到电路图图片](/project_3_Car_Learning/小车电路图.png小车电路图.png)\r\n+![未能找到电路图图片](/project_3_Car_Learning/小车电路图.png)\r\n \r\n ## 二、软件架构实现\r\n \r\n ### 2.1 开发环境\r\n"
                }
            ],
            "date": 1748767291179,
            "name": "Commit-0",
            "content": "# 2024年小车电赛文档\r\n\r\n## 项目概述\r\n\r\n本项目是基于嘉立创地猛星（MSPM0G3507）最小系统板的智能巡线小车，旨在完成2024年电赛H题。采用五路红外传感器实现路径识别，通过PID算法进行闭环控制，具备蓝牙通信等功能。\r\n\r\n## 小组成员\r\n\r\n|姓名      |学号      |\r\n|---------|----------|\r\n|杨家宝    |2024522007|\r\n|刘书航    ||\r\n|杨惠钧    ||\r\n\r\n## 一、硬件架构设计\r\n\r\n### 1.1 硬件示意图\r\n\r\n```mermaid\r\ngraph TD\r\nA[主控 MSPM0G3507] --> B[动力系统]\r\nA --> C[感知系统]\r\nA --> D[通信系统]\r\nB --> B1[TB6612驱动]\r\nB --> B2[370直流电机x2]\r\nB --> B3[编码器x2]\r\nC --> C1[五路红外阵列]\r\nC --> C2[JY62陀螺仪]\r\nD --> D1[HC-06蓝牙]\r\nE[锂电池4S] --> F[LM2596 DC-DC]\r\nF --> G[AMS1117-3.3 LDO]-->A\r\nF --> H[MP1584EN降压]-->B\r\n```\r\n\r\n### 1.2 关键引脚分配表\r\n\r\n| 功能模块       | 引脚    | 信号类型 | 连接器件     |\r\n|----------------|---------|----------|--------------|\r\n| **电机驱动**   | A12     | GPIO     | TB6612_STBY  |\r\n|                | B6-B7   | PWM      | TB6612_AIN1-2|\r\n|                | A8-A9   | PWM      | TB6612_BIN1-2|\r\n| **编码器接口** | B24-B20 | QEI      | 左电机编码器 |\r\n|                | A16-A15 | QEI      | 右电机编码器 |\r\n| **红外阵列**   | A23-A27 | GPIO     | TRK1-TRK5    |\r\n| **蓝牙模块**   | A21-A22 | UART     | HC-06        |\r\n| **陀螺仪**     | A28-A31 | I2C      | JY62         |\r\n\r\n### 1.3 电源树设计\r\n\r\n| 电源模块      | 输入电压 | 输出电压 | 最大电流 | 供电目标         |\r\n|---------------|----------|----------|----------|------------------|\r\n| 锂电池组      | 14.8V    | 12V        | 3A       | 动力系统         |\r\n| LM2596       | 14.8V    | 5V       | 2A       | 控制电路         |\r\n| AMS1117-3.3  | 5V       | 3.3V     | 800mA    | MCU及数字电路    |\r\n| MP1584EN     | 14.8V    | 5V        | 3A       | 红外传感器阵列   |\r\n\r\n### 1.4 电路图\r\n\r\n![未能找到电路图图片](project_3_Car_Learning\\小车电路图.png)\r\n\r\n## 二、软件架构实现\r\n\r\n### 2.1 开发环境\r\n\r\n* TI官方提供的*CCS20.1.1*\r\n\r\n### 2.1 模块化文件结构\r\n\r\n``` markdown\r\n工程根目录/\r\n├── app/                # 应用层模块\r\n│   ├── buzzer/         # 蜂鸣器驱动\r\n│   ├── encoder/        # 编码器接口\r\n│   ├── hc_06/          # 蓝牙通信模块\r\n│   ├── motor/          # 电机控制核心\r\n│   ├── jdy62/          # 姿态传感器\r\n│   ├── tb6612/         # 驱动芯片底层\r\n│   └── tracking/       # 巡线算法实现\r\n│   └── control/        # 逻辑控制代码\r\n├── lib/                # 通用库文件\r\n│   ├── delay/          # 延时函数\r\n│   ├── key/            # 按键检测\r\n│   ├── pid/            # PID算法库\r\n│   ├── task/           # 任务调度器\r\n│   └── uart/           # 串口通信库\r\n└── src/                # 主程序\r\n    ├── main.c          # 系统初始化与主循环\r\n\r\n```\r\n\r\n## 三、核心算法实现\r\n\r\n### 3.1 电机PWM控制\r\n\r\n此部分是通过tb6612和PWM信号来驱动电机进行旋转\r\n\r\n```c\r\nvoid SetPWM_R(float duty)\r\n{\r\n    if (duty > 0)\r\n    {\r\n        // 正向旋转\r\n        AIN1_OUT(0);\r\n        AIN2_OUT(1);\r\n    }\r\n    else if (duty < 0)\r\n    {\r\n        // 反向旋转\r\n        duty = -duty;\r\n        AIN1_OUT(1);\r\n        AIN2_OUT(0);\r\n    }\r\n    else\r\n    {\r\n        // 停止\r\n        AIN1_OUT(0);\r\n        AIN2_OUT(0);\r\n    }\r\n    \r\n    // 将占空比转换为定时器的比较值\r\n    uint32_t ccr = duty / 100.0f * 1000;\r\n    // 设置PWM值\r\n    DL_TimerG_setCaptureCompareValue(PWM_R_INST, ccr, GPIO_PWM_R_C0_IDX);\r\n    ···\r\n}\r\n```\r\n\r\n### 3.3 PID算法实现\r\n\r\n此部分采用了增量式PID算法。\r\n```c\r\nfloat PID_Compute(PID_Typedef *PIDx, float fb)\r\n{\r\n    PIDx->err = PIDx->sp - fb;  // 计算当前误差\r\n    \r\n    // 增量式PID算法\r\n    PIDx->co += PIDx->kp * (PIDx->err - PIDx->last_err) +\r\n                PIDx->ki * PIDx->err +\r\n                PIDx->kd * (PIDx->err - 2 * PIDx->last_err + PIDx->last2_err);\r\n    \r\n    PIDx->last2_err = PIDx->last_err;  // 更新上上次误差\r\n    PIDx->last_err = PIDx->err;        // 更新上次误差\r\n    \r\n    if(PIDx->co<=0.7&&PIDx->co>=0.7)\r\n    {\r\n        PIDx->co = 0;\r\n    }\r\n\r\n    return PIDx->co;\r\n}\r\n···\r\n```\r\n\r\n### 3.4 电机进程\r\n\r\n此部分差速环作为外环，先通过逻辑判断并计算差速，再传给内环速度环解算出最后传给电机的PWM信号\r\n\r\n```c\r\n// motor.c\r\nvoid Motor_Proc()\r\n{\r\n    float speed_l = target_speed_l;\r\n    float speed_r = target_speed_r;\r\n    if(tracking_flag == 1)\r\n    {\r\n        duty_diff = PID_Compute(&pid_tracking, Tracking_Angle());\r\n        speed_l -= duty_diff;\r\n        speed_r += duty_diff;\r\n    }\r\n    else \r\n    {\r\n        duty_diff = PID_Compute_dir(&pid_direction, JY62_Get_Yaw());\r\n        speed_l -= duty_diff;\r\n        speed_r += duty_diff;\r\n    }\r\n    \r\n    Motor_Control_L(speed_l);\r\n    Motor_Control_R(speed_r);\r\n}\r\n\r\nvoid Motor_Control_L(float target_speed)\r\n{\r\n    if(IF_SPEED_ZERO(target_speed))\r\n    {\r\n        PID_Reset(&pid_l_speed);\r\n        SetPWM_L(0);\r\n        return;\r\n    }\r\n        omeg_l = Encoder_Get_L_Speed();\r\n        PID_ChangeSP(&pid_l_speed, target_speed);\r\n        duty_l = PID_Compute(&pid_l_speed, omeg_l);\r\n        PID_Limmit(&duty_l, 100.0, -100.0);\r\n        SetPWM_L(duty_l);\r\n}\r\n···\r\n```\r\n\r\n### 3.2 红外循迹算法\r\n\r\n此部分通过给红外传感器不同的权重，实现差速调节，小车循迹\r\n\r\n```c\r\n// tracking.c\r\nvoid HW_Detect() {\r\n    Tracking_value = 0;\r\n    \r\n    /* 传感器加权策略 */\r\n    if(P1) Tracking_value -= 9;\r\n    if(P2) Tracking_value -= 6;  // 左偏检测\r\n    if(P3) Tracking_value += 0;  // 中心点不参与计算\r\n    if(P4) Tracking_value += 6;  // 右偏检测\r\n    if(P5) Tracking_value += 9;\r\n}\r\n```\r\n\r\n### 3.3 陀螺仪数据解算\r\n\r\n此部分参考官方文档，对JY62发送的串口消息进行结算，获取实时角度\r\n\r\n```c\r\n// jy62.c\r\nuint8_t JY62_CalculateAngles(const uint8_t *rawData, JY62AnglesData *angles)\r\n{\r\n    // 确保数据有效\r\n    if (rawData[0] != 0x55 || rawData[1] != 0x53) {\r\n        return 0;  // 头部不正确\r\n    }\r\n    \r\n    // 提取各字节\r\n    uint8_t RollL = rawData[2];\r\n    uint8_t RollH = rawData[3];\r\n    uint8_t PitchL = rawData[4];\r\n    uint8_t PitchH = rawData[5];\r\n    uint8_t YawL = rawData[6];\r\n    uint8_t YawH = rawData[7];\r\n    uint8_t VL = rawData[8];\r\n    uint8_t VH = rawData[9];\r\n    uint8_t SUM = rawData[10];\r\n    \r\n    // 校验SUM是否正确\r\n    uint8_t calculatedSum = 0x55 + 0x53 + RollH + RollL + PitchH + PitchL + YawH + YawL + VH + VL;\r\n    \r\n    if (calculatedSum != SUM) {\r\n        jy62Debug.checksumErrors++;\r\n        angles->isValid = 0;\r\n        return 0;  // 校验失败\r\n    }\r\n    \r\n    // 处理Roll角度\r\n    int16_t rollRaw = ((uint16_t)RollH << 8) | RollL;\r\n    float rollTemp = (float)rollRaw / 32768.0f * 180.0f;\r\n    angles->roll = (rollTemp > 180.0f) ? (rollTemp - 360.0f) : rollTemp;\r\n    \r\n    // 处理Pitch角度\r\n    int16_t pitchRaw = ((uint16_t)PitchH << 8) | PitchL;\r\n    float pitchTemp = (float)pitchRaw / 32768.0f * 180.0f;\r\n    angles->pitch = (pitchTemp > 180.0f) ? (pitchTemp - 360.0f) : pitchTemp;\r\n    \r\n    // 处理Yaw角度\r\n    int16_t yawRaw = ((uint16_t)YawH << 8) | YawL;\r\n    float yawTemp = (float)yawRaw / 32768.0f * 180.0f;\r\n    angles->yaw = (yawTemp > 180.0f) ? (yawTemp - 360.0f) : yawTemp;\r\n    \r\n    angles->isValid = 1;  // 标记数据有效\r\n    return 1;  // 计算成功\r\n}\r\n```\r\n\r\n### 3.4 按键处理\r\n\r\n此部分通过按钮的消抖和状态检测，通过回调函数实现执行长按，短按，连击的对应事件\r\n\r\n```c\r\n//key.c\r\nvoid Key_Proc(Key_TypeDef *Key)\r\n{\r\n    uint8_t currentState;\r\n    uint32_t currentTime = get_ticks();\r\n\r\n    if (Key->ChangePending)\r\n    {\r\n        // 消抖处理\r\n        if (currentTime - Key->PendingTime >= KEY_SETTLING_TIME)\r\n        {\r\n            currentState = DL_GPIO_readPins(Key->key_port, Key->key_pin) > 0 ? 1 : 0;\r\n            if (currentState != Key->LastState)\r\n            {\r\n                if (currentState == 1) \r\n                    OnKeyPressed(Key);\r\n                else \r\n                    OnKeyReleased(Key);\r\n            }\r\n            Key->LastState = currentState;\r\n            Key->ChangePending = 0;\r\n        }\r\n    }\r\n    else \r\n    {\r\n        currentState = DL_GPIO_readPins(Key->key_port, Key->key_pin) > 0 ? 1 : 0;\r\n        if (currentState != Key->LastState)\r\n        {\r\n            Key->ChangePending = 1;\r\n            Key->PendingTime = currentTime;\r\n        }\r\n    }\r\n    OnKeyEveryPolled(Key, Key->LastState, currentTime);\r\n}\r\n\r\n/**\r\n * @brief 获取按钮当前状态\r\n * @param Key 按钮结构体指针\r\n * @return 按钮状态（0：松开，1：按下）\r\n */\r\nuint8_t Key_GetState(Key_TypeDef *Key)\r\n{\r\n    return Key->LastState;\r\n}\r\n\r\n/**\r\n * @brief 按钮按下事件处理\r\n * @param Key 按钮结构体指针\r\n */\r\nstatic void OnKeyPressed(Key_TypeDef *Key)\r\n{\r\n    Key->LastPressedTime = get_ticks();\r\n    if (Key->key_pressed_cb != 0)\r\n    {\r\n        Key->key_pressed_cb();\r\n    }\r\n}\r\n\r\n/**\r\n * @brief 按钮松开事件处理\r\n * @param Key 按钮结构体指针\r\n */\r\nstatic void OnKeyReleased(Key_TypeDef *Key)\r\n{\r\n    Key->LastReleasedTime = get_ticks();\r\n    if (Key->key_released_cb != 0)\r\n    {\r\n        Key->key_released_cb();\r\n    }\r\n    \r\n    Key->LongPressTicks = 0;\r\n    \r\n    if (Key->LastReleasedTime - Key->LastPressedTime < Key->LongPressThreshold)\r\n    {\r\n        Key->ClickCnt++;\r\n    }\r\n    else\r\n    {\r\n        Key->ClickCnt = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @brief 按钮轮询处理\r\n * @param Key 按钮结构体指针\r\n * @param State 当前按钮状态\r\n * @param CurrentTime 当前时间\r\n */\r\nstatic void OnKeyEveryPolled(Key_TypeDef *Key, uint8_t State, uint32_t CurrentTime)\r\n{\r\n    // 处理长按\r\n    if (Key->LastState == 1)\r\n    {\r\n        if (Key->LongPressTicks == 0)\r\n        {\r\n            if (Key->LastPressedTime != 0 && \r\n                CurrentTime - Key->LastPressedTime > Key->LongPressThreshold)\r\n            {\r\n                Key->LongPressTicks = 1;\r\n                if (Key->key_long_pressed_cb)\r\n                {\r\n                    Key->key_long_pressed_cb(Key->LongPressTicks);\r\n                }\r\n                Key->LastLongPressTickTime = get_ticks();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (CurrentTime - Key->LastLongPressTickTime > Key->LongPressTickInterval)\r\n            {\r\n                Key->LastLongPressTickTime = get_ticks();\r\n                Key->LongPressTicks++;\r\n                if (Key->key_long_pressed_cb)\r\n                {\r\n                    Key->key_long_pressed_cb(Key->LongPressTicks);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // 处理多击\r\n    if (Key->ClickCnt > 0 && Key->LastState == 0 && \r\n        (get_ticks() - Key->LastReleasedTime) > Key->ClickInterval)\r\n    {\r\n        if (Key->key_clicked_cb)\r\n        {\r\n            Key->key_clicked_cb(Key->ClickCnt);\r\n        }\r\n        Key->ClickCnt = 0;\r\n    }\r\n}\r\n```\r\n\r\n### 3.5蜂鸣器控制\r\n\r\n此部分通过获取系统时间，PWM控制，使蜂鸣器可以产生不同周期的不同音量的声音信号\r\n\r\n```c\r\n//buzzer.c\r\nvoid Buzzer_Proc()\r\n{\r\n    uint32_t current_tick = get_ticks();\r\n    // 如果未激活，直接返回\r\n    if (!buzzer.is_active) {\r\n        Buzzer_Off();\r\n        return;\r\n    }\r\n    // 计算经过的时间\r\n    uint32_t elapsed = current_tick - buzzer.start_tick;\r\n    // 完成所有重复\r\n    if (buzzer.current_count >= buzzer.repeat_count) {\r\n        buzzer.is_active = 0;\r\n        Buzzer_Off();\r\n        return;\r\n    }\r\n    // 判断当前是鸣叫还是静音状态\r\n    if (elapsed % (buzzer.duration + buzzer.interval) < buzzer.duration) {\r\n        Buzzer_On();\r\n    } else {\r\n        Buzzer_Off();\r\n        \r\n        // 如果一个周期结束，增加重复计数\r\n        if (elapsed % (buzzer.duration + buzzer.interval) == 0) {\r\n            buzzer.current_count++;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.6编码器速度解算\r\n\r\n此部分通过GPIO中断，采用二倍频计数，获取编码器位置，进而通过定时器结算实时速度\r\n\r\n```c\r\n//encoder.c\r\n/**\r\n * @brief 编码器读取中断服务函数\r\n * \r\n * 该函数在定时器中断触发时调用，用于读取和重置编码器计数值\r\n */\r\nvoid TIMER_Encoder_Read_INST_IRQHandler(void)\r\n{\r\n    switch (DL_TimerG_getPendingInterrupt(TIMER_Encoder_Read_INST)){\r\n        case DL_TIMER_IIDX_ZERO:\r\n            // 更新速度值并重置计数器\r\n            Encoder_L_VEL = Encoder_L_CNT;\r\n            Encoder_L_CNT = 0;\r\n            Encoder_R_VEL = Encoder_R_CNT;\r\n            Encoder_R_CNT = 0;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n/**\r\n * @brief 编码器GPIO中断处理函数\r\n * \r\n * 该函数处理编码器A和B的GPIO中断，更新编码器计数值\r\n */\r\nvoid GROUP1_IRQHandler(void)\r\n{\r\n    // 获取左右编码器的中断状态\r\n    Encoder_L_Port = DL_GPIO_getEnabledInterruptStatus(GPIO_Encoder_L_PORT, GPIO_Encoder_L_L_A_PIN | GPIO_Encoder_L_L_B_PIN);\r\n    Encoder_R_Port = DL_GPIO_getEnabledInterruptStatus(GPIO_Encoder_R_PORT, GPIO_Encoder_R_R_A_PIN | GPIO_Encoder_R_R_B_PIN);\r\n    \r\n    /* 处理左编码器 */\r\n    if((Encoder_L_Port & GPIO_Encoder_L_L_A_PIN) == GPIO_Encoder_L_L_A_PIN)\r\n    {\r\n        // 根据B相状态判断旋转方向\r\n        if(!DL_GPIO_readPins(GPIO_Encoder_L_PORT,GPIO_Encoder_L_L_B_PIN))   {Encoder_L_CNT--;Encoder_L_INT--;}\r\n        else                                                                {Encoder_L_CNT++;Encoder_L_INT++;}\r\n    }\r\n    else if((Encoder_L_Port & GPIO_Encoder_L_L_B_PIN) == GPIO_Encoder_L_L_B_PIN)\r\n    {\r\n        // 根据A相状态判断旋转方向\r\n        if(!DL_GPIO_readPins(GPIO_Encoder_L_PORT,GPIO_Encoder_L_L_A_PIN))   {Encoder_L_CNT++;Encoder_L_INT++;}\r\n        else                                                                {Encoder_L_CNT--;Encoder_L_INT--;}\r\n    }\r\n    // 清除左编码器中断标志\r\n    DL_GPIO_clearInterruptStatus(GPIO_Encoder_L_PORT, GPIO_Encoder_L_L_A_PIN|GPIO_Encoder_L_L_B_PIN);\r\n\r\n    /* 处理右编码器 */\r\n    if((Encoder_R_Port & GPIO_Encoder_R_R_A_PIN) == GPIO_Encoder_R_R_A_PIN)\r\n    {\r\n        // 根据B相状态判断旋转方向\r\n        if(!DL_GPIO_readPins(GPIO_Encoder_R_PORT,GPIO_Encoder_R_R_B_PIN))    {Encoder_R_CNT--;Encoder_R_INT--;}\r\n        else                                                                {Encoder_R_CNT++;Encoder_R_INT++;}\r\n    }\r\n    else if((Encoder_R_Port & GPIO_Encoder_R_R_B_PIN) == GPIO_Encoder_R_R_B_PIN)\r\n    {\r\n        // 根据A相状态判断旋转方向\r\n        if(!DL_GPIO_readPins(GPIO_Encoder_R_PORT,GPIO_Encoder_R_R_A_PIN))   {Encoder_R_CNT++;Encoder_R_INT++;}\r\n        else                                                                {Encoder_R_CNT--;Encoder_R_INT--;}\r\n    }\r\n    // 清除右编码器中断标志\r\n    DL_GPIO_clearInterruptStatus(GPIO_Encoder_R_PORT, GPIO_Encoder_R_R_A_PIN|GPIO_Encoder_R_R_B_PIN);\r\n}\r\n\r\n```\r\n\r\n### 3.7任务控制\r\n\r\n此部分为此次赛题的核心逻辑控制，并且将不能被打断的电机进程放进定时器中，定时器周期设定的尽量小。\r\n\r\n```c\r\n//control.c\r\nvoid Control_AB(void)\r\n{\r\n    if(state == 0)\r\n    {\r\n        BUZZER_LONG_BEEP;         // 蜂鸣器提示\r\n        tracking_flag = 0;         // 关闭循迹\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        Motor_direction(0);        // 设置电机方向\r\n        // 检测是否脱离黑线\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > AB_WHITE_CNT)             \r\n            {\r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // 状态1：检测黑线\r\n    else if(state == 1)\r\n    {\r\n        Motor_direction(0);\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > AB_BLACK_CNT)             // 检测到黑线持续\r\n            {\r\n                BUZZER_LONG_BEEP;\r\n                state = 2;            // 进入状态二\r\n                cnt = 0;\r\n                Motor_SetSpeed_R(0);   // 设置右电机速度\r\n                Motor_SetSpeed_L(0);   // 设置左电机速度\r\n                return;\r\n            }\r\n        }\r\n        else cnt = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @brief 巡线小车椭圆路径运动控制函数（ABCDA)\r\n * @details 通过状态机实现小车在两个半圆上连续运动1圈\r\n * 状态机工作流程：\r\n * - state 0: 从A运动到B,走0度直线\r\n * - state 1: 检测到达B点，并回正\r\n * - state 2：从B巡线到C\r\n * - state 3: 从C运动到D，走225度直线\r\n * - state 4: 从D运动到A，在结尾处回正\r\n */\r\nvoid Control_ABCD(void)\r\n{\r\n       // 状态0：初始行驶状态\r\n    if(state == 0)\r\n    {\r\n        tracking_flag = 0;         // 关闭循迹\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        Motor_direction(0);        // 设置电机方向直行\r\n        \r\n        // 检测是否脱离黑线\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > ABCD_WHITE_CNT)             \r\n            {\r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        }\r\n        else cnt = 0;\r\n    }\r\n    // 状态1：检测到B点并回正\r\n    else if(state == 1)\r\n    {\r\n        // 类似Task_3中状态1的回正逻辑\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > ABCD_BLACK_CNT)             \r\n            {\r\n                    \r\n                    BUZZER_LONG_BEEP;   // 进入状态2\r\n                    state = 2;  \r\n                    tracking_flag = 1;             \r\n                    cnt = 0;\r\n                    return;\r\n            }\r\n        }else cnt = 0;\r\n    }\r\n        \r\n    // 状态2：进入循迹模式（从B到C）\r\n    else if (state == 2)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > ABCD_WHITE_CNT)             \r\n            {   \r\n                BUZZER_LONG_BEEP;                \r\n                state = 3;           \r\n                tracking_flag = 0;\r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态3：从C运动到D\r\n    else if (state == 3)\r\n    {\r\n        \r\n        Motor_direction(178);\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > ABCD_BLACK_CNT)             \r\n            {\r\n                BUZZER_LONG_BEEP;                \r\n                state = 4;           \r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态4：从D运动到A\r\n    else if (state == 4)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > ABCD_WHITE_CNT)             \r\n            {\r\n                BUZZER_LONG_BEEP;                \r\n                state = 0;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @brief 巡线小车8字路径运动控制函数(ACBDA)\r\n * @details 通过状态机实现小车在两个半圆上连续运动1圈\r\n * 状态机工作流程：\r\n * - state 0: 从A运动到C,走-45度直线\r\n * - state 1: 检测到达C点，并回正\r\n * - state 2：从C巡线到B，并在B点回正\r\n * - state 3: 从B运动到D，走225度直线\r\n * - state 4: 从D运动到A，在结尾处回正\r\n */\r\nvoid Control_ACBD(void)\r\n{// 状态0：初始行驶状态\r\n    if(state == 0)\r\n    {\r\n        if(state == 0)\r\n        {\r\n        tracking_flag = 0;         // 关闭循迹\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        Motor_direction(0);        // 设置电机方向直行\r\n        }\r\n        // 检测是否脱离黑线\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt > ACBD_WHITE_CNT)             \r\n            {\r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                return;\r\n            }\r\n        }\r\n        else cnt = 0;\r\n    }\r\n    // 状态1：检测到B点并回正\r\n    else if(state == 1)\r\n    {\r\n        if(turning_flag == 0)\r\n            last_turned_ticks = get_ticks();\r\n        turning_flag = 1;\r\n        if(get_ticks()-last_turned_ticks < 1000)\r\n        {\r\n            Motor_SetSpeed_R(0);\r\n            Motor_SetSpeed_L(0);   \r\n            Motor_direction(-40);\r\n            \r\n            return;\r\n        }\r\n        Motor_SetSpeed_R(speed);\r\n        Motor_SetSpeed_L(speed);\r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt >ACBD_BLACK_CNT)             \r\n            {\r\n                turning_flag = 0;\r\n                BUZZER_LONG_BEEP;\r\n                state = 2;  \r\n                tracking_flag = 1;             \r\n                cnt = 0;\r\n                return;\r\n            }\r\n        }else cnt = 0;\r\n    }\r\n        \r\n    // 状态2：进入循迹模式（从B到C）\r\n    else if (state == 2)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt >ACBD_WHITE_CNT)             \r\n            {   \r\n                BUZZER_LONG_BEEP;                \r\n                state = 3;           \r\n                tracking_flag = 0;\r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态3：从C运动到D\r\n    else if (state == 3)\r\n    {\r\n        \r\n        if(turning_flag == 0)\r\n            last_turned_ticks = get_ticks();\r\n        turning_flag = 1;\r\n        if(get_ticks()-last_turned_ticks < 2000)\r\n        {\r\n            Motor_SetSpeed_R(0);   // 设置右电机速度\r\n            Motor_SetSpeed_L(0);   // 设置左电机速度\r\n            Motor_direction(-140);\r\n            return;\r\n        }\r\n        Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n        Motor_SetSpeed_L(speed);   // 设置左电机速度\r\n        \r\n        if(IS_INBLACK())\r\n        {\r\n            cnt++;\r\n            if(cnt > ACBD_BLACK_CNT)             \r\n            {\r\n                Motor_SetSpeed_R(speed);   // 设置右电机速度\r\n                Motor_SetSpeed_L(speed);\r\n                turning_flag = 0;\r\n                BUZZER_LONG_BEEP;                \r\n                state = 4;           \r\n                cnt = 0;\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n    // 状态4：从D运动到A\r\n    else if (state == 4)\r\n    {\r\n        tracking_flag = 1;\r\n        if(!(IS_INBLACK()))\r\n        {\r\n            cnt++;\r\n            if(cnt >ACBD_WHITE_CNT)             \r\n            {\r\n                BUZZER_LONG_BEEP;                \r\n                state = 1;           \r\n                cnt = 0;\r\n                tracking_flag = 0;\r\n                Motor_SetSpeed_L(0);\r\n                Motor_SetSpeed_R(0);\r\n                return;\r\n            }\r\n        } \r\n        else cnt = 0;\r\n    }\r\n}\r\nvoid key_pressed_cb(void);\r\nvoid key_long_pressed_cb(uint8_t ticks);\r\n\r\nvoid My_Key_Init()\r\n{\r\n    Key_InitTypedef Key_Initstruct;\r\n    Key_Initstruct.key_pin = Key_k1_PIN;\r\n    Key_Initstruct.key_port = Key_PORT;\r\n    Key_Initstruct.key_pressed_cb = key_pressed_cb;\r\n    Key_Initstruct.key_long_pressed_cb = key_long_pressed_cb;\r\n\r\n    Key_Init(&Key1, &Key_Initstruct);\r\n}\r\n\r\nvoid key_pressed_cb(void)\r\n{\r\n    mode++;\r\n}\r\nvoid key_long_pressed_cb(uint8_t ticks)\r\n{\r\n    mode = 0;\r\n}\r\n\r\nvoid TIMG7_IRQHandler(void)\r\n{\r\n    JY62_UpdateAngles();\r\n    Motor_Proc();\r\n    Buzzer_Proc();\r\n}\r\n```\r\n\r\n## 四、成品展示及其源码地址\r\n\r\n### 4.1源码地址\r\n\r\nhttps://github.com/Monglitay/-NUEDC-Projects/tree/main/project_3_Car_Learning/Patrol%20Car\r\n\r\n## 4.2视频链接\r\n"
        }
    ]
}